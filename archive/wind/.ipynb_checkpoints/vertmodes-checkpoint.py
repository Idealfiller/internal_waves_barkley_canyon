{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "120393b1",
   "metadata": {},
   "outputs": [],
   "source": [
    "from matplotlib import pylab\n",
    "\n",
    "def vertModes(N2,dz,nmodes=0): \n",
    "    \"\"\"\" psi,phi,ce,z=vertModes(N2,dz,nmodes=0)\n",
    "    \n",
    "    Compute the vertical eigen modes of the internal wave solution on a flat bottom\n",
    "    \n",
    "    Parameters:\n",
    "    ----------- \n",
    "    N2 : (M) is buoyancy frequency squared (rad^2/s^2) as an 1-D\n",
    "         array.  If there are M values of N2, the first one is assumed\n",
    "         to be at dz/2 deep, and the last one is H-dz/2 deep.  The\n",
    "         water column is assumed to be H=M*dz deep.  No gaps are\n",
    "         allowed, and N2>0 everywhere.       \n",
    "    dz : is a single value, and the distance (in meters) between the N2 estimates\n",
    "    nmodes : number of modes to return.  nmodes = 0 means return M-3 modes.\n",
    "            \n",
    "         \n",
    "    Returns:\n",
    "    --------\n",
    "    psi : (M,M-2) is the vertical structure function at\n",
    "         z=dz/2,3dz/2,2dz...,H-dz/2.  Note there is one extra value\n",
    "         compared to N2 (ie there are M+1 values in depth). psi is\n",
    "         normalized so that sum(psi^2 dz) = 1.  For internal waves,\n",
    "         psi is approriate for velocity and pressure vertical\n",
    "         structure.          \n",
    "    phi : (M,M-2) is the vertical integral of psi (phi = int psi dz)\n",
    "         and represents the vertical velocity structure.  It is\n",
    "         interpolated onto the same grid as psi.\n",
    "    ce : (M-2) is the non-rotating phase speed of the waves in m/s.\n",
    "    z :  (M) is the vertical position of the psi and phi vector elements.\n",
    "             \n",
    "    Notes: \n",
    "    ------\n",
    "    This solves 1/N**2 psi_{zz} + (1/ce**2)psi = 0 subject to a\n",
    "    boundary condition of zero vertical velocity at the surface and\n",
    "    seafloor.\n",
    "  \n",
    "    psi(0)=0 (rigid lid approx)\n",
    "    psi(H)=0\n",
    "    \n",
    "    It is solved as an eigenvalue problem.  \n",
    "    Also note that if \n",
    "             \n",
    "    J. Klymak (Based on code by Sam Kelly and Gabe Vecchi)           \n",
    "    \"\"\"\n",
    "\n",
    "    import numpy as np\n",
    "    \n",
    "    # First we are solving for w on dz,2dz,3dz...H-dz\n",
    "    M = np.shape(N2)[0]-1\n",
    "        \n",
    "    if M>200:\n",
    "        sparse = True\n",
    "        if nmodes==0:\n",
    "            nmodes = 100 # don't try too many eigenvectors in sparse mode...\n",
    "    else:\n",
    "        sparse = False\n",
    "        if nmodes==0:\n",
    "            nmodes = M-2\n",
    "    \n",
    "    N2mid = N2[:-1]+np.diff(N2)/2.\n",
    "    # matrix for second difference operator\n",
    "    D = np.diag(-2.*np.ones(M),0)\n",
    "    D += np.diag(1.*np.ones(M-1),-1)\n",
    "    D += np.diag(1.*np.ones(M-1),1)\n",
    "\n",
    "    D=-D/dz/dz\n",
    "    D = np.diag(1./N2mid).dot(D)\n",
    "    ce,W = np.linalg.eig(D)\n",
    "    # psi is such that sum(psi^2)=1 but we want sum(psi^2 dz)=1.\n",
    "    W = W/np.sqrt(dz)\n",
    "    ce = 1./np.sqrt(ce)\n",
    "    ind=np.argsort(-ce)\n",
    "    \n",
    "    ce=ce[ind[:-2]]\n",
    "    W=W[:,ind[:-2]]\n",
    "    # zphi\n",
    "    zphi = np.linspace(dz/2.,(M+1)*dz-dz/2.,M+1)\n",
    "\n",
    "    # now get phi (w structure) on dz/2,3dz/2...\n",
    "    phi = np.zeros((M+1,M+1-3))\n",
    "    phi[0,:]=0.5*(W[0,:])\n",
    "    phi[1:-1,:]=0.5*(W[:-1,:]+W[1:,:])\n",
    "    phi[-1,:]=0.5*(W[-1,:])\n",
    "    \n",
    "    # Now get psi (u/p structure) on dz/2,3dz/2...\n",
    "    psi = np.zeros((M+1,M+1-3))\n",
    "    psi[0,:] = W[0,:]\n",
    "    psi[1:-1,] = np.diff(W,axis=0)\n",
    "    psi[-1,:] = -W[-1,:]\n",
    "    \n",
    "    A = np.sqrt(np.sum(psi*psi,axis=0)*dz)\n",
    "    psi = psi/A\n",
    "    phi = phi/A\n",
    "    # flip sign so always same sign in psi at top:\n",
    "    phi[:,psi[0,:]<0] *= -1\n",
    "    psi[:,psi[0,:]<0] *= -1\n",
    "\n",
    "    return psi,phi,ce,zphi"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.8"
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": true,
   "sideBar": true,
   "skip_h1_title": false,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": false,
   "toc_position": {},
   "toc_section_display": true,
   "toc_window_display": false
  },
  "varInspector": {
   "cols": {
    "lenName": "16",
    "lenType": "16",
    "lenVar": 40
   },
   "kernels_config": {
    "python": {
     "delete_cmd_postfix": "",
     "delete_cmd_prefix": "del ",
     "library": "var_list.py",
     "varRefreshCmd": "print(var_dic_list())"
    },
    "r": {
     "delete_cmd_postfix": ") ",
     "delete_cmd_prefix": "rm(",
     "library": "var_list.r",
     "varRefreshCmd": "cat(var_dic_list()) "
    }
   },
   "types_to_exclude": [
    "module",
    "function",
    "builtin_function_or_method",
    "instance",
    "_Feature"
   ],
   "window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
